                                      Project Report
                                Twitter Sentimental Analysis
                                â€ƒ


1.	Abstract:
Sentiment analysis on Twitter data has become increasingly important in understanding public opinion and sentiment trends. In this project, we perform sentiment analysis on Twitter data using machine learning techniques. Our approach involves preprocessing the Twitter text data, including cleaning, tokenization, and vectorization. We then build a sentiment classification model using Multinomial Naive Bayes and evaluate its performance on a test dataset. 



2.	Introduction:
With the proliferation of social media platforms like Twitter, understanding the sentiment of users has become crucial for various applications such as brand monitoring, market research, and public opinion analysis. Sentiment analysis, also known as opinion mining, involves extracting and analyzing sentiment information from text data. In this project, we focus on sentiment analysis of Twitter data. We aim to develop a machine learning model capable of classifying the sentiment of tweets as positive or negative.



3.	Implementation Details:
1.	Library Import
import pandas as pd
import numpy as np
import nltk
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
from nltk.stem import WordNetLemmatizer
import re
from sklearn.model_selection import train_test_split

This section imports necessary libraries for data manipulation, natural language processing (NLP), and machine learning.

2.	Dataset Import and Exploration
dataset = pd.read_csv('C:/Users/Hp/Desktop/datascience PROJECTS/Sentimental Analysis/Twitter analysis/Sentiment.csv')
print(dataset)
dataset = dataset[['text','sentiment']]
print(dataset)
dataset = dataset[dataset['sentiment']!= 'Neutral']
print(dataset)

Here, the dataset is imported from a CSV file and explored. It is then filtered to remove tweets with neutral sentiment.

3.	Data Preprocessing
train,test = train_test_split(dataset,test_size=0.1)
print(train)
print(test)
print(train['text'][9720])

The dataset is split into training and testing sets. A sample tweet is printed to ensure data integrity.

4.	Text Cleaning and Preprocessing
pattern = r"(#\w+)|(RT\s@\w+:)|(http.*)|(@\w+)"
ps = PorterStemmer()
lemmatizer = WordNetLemmatizer()

def Clean_text(data):
    tweets = []
    sentiments = []
    for index,row in data.iterrows():
        sentence = re.sub(pattern,'',row.text)
        words = [e.lower() for e in sentence.split()]
        words = [lemmatizer.lemmatize(word) for word in words if word not in stopwords.words('english')]
        words = ' '.join(words)
        tweets.append(words)
        sentiments.append(row.sentiment)
    return tweets,sentiments

This section defines a function to clean and preprocess the text data, including removing special characters, stopwords, and performing lemmatization.

5.	Label Encoding
from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()
processed_data['sentiments'] = labelencoder.fit_transform(processed_data['sentiments'])
print(processed_data)

The sentiment labels are encoded into numerical values using LabelEncoder for model compatibility.

6.	Vectorization
from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(ngram_range=(1,3))
cv.fit(processed_data['tweets'])

X_train = cv.transform(processed_data['tweets'])
print(X_train.shape)
print(X_train.toarray())

The text data is converted into numerical vectors using CountVectorizer, which creates a matrix of word frequencies.

7. Model Building (Naive Bayes)
from sklearn.naive_bayes import MultinomialNB
classifier = MultinomialNB()
print(classifier.fit(X_train.toarray(),target))

A Multinomial Naive Bayes classifier is trained using the vectorized training data.

8. Testing and Evaluation
test_tweets,test_sentiments = Clean_text(test)

data_test = {'tweets':test_tweets,'sentiments':test_sentiments}
final_test_data = pd.DataFrame(data_test)

X_test = cv.transform(final_test_data['tweets'])
print(X_test.shape)

y_pred = classifier.predict(X_test.toarray())

The trained model is tested on the test dataset, and predictions are made on the test data.

9. Results Analysis
final_test_data['sentiments'] = labelencoder.fit_transform(final_test_data['sentiments'])
print(final_test_data)

actual_values = final_test_data['sentiments'].values
print(actual_values)

from sklearn.metrics import accuracy_score
print(accuracy_score(y_pred,actual_values))

The predicted sentiments are compared against the actual sentiments from the test data, and accuracy is calculated using the accuracy_score metric.

10. Checking
print(final_test_data)
print(X_test.toarray()[0])
print("Predicted Sentiment:",classifier.predict(X_test.toarray()[[0]]))
The final test data and the sentiment prediction for a sample tweet are printed, concluding the sentiment analysis process.



4.	Result:
The Multinomial Naive Bayes classifier achieved an accuracy of 80+ on the test dataset, demonstrating the effectiveness of the sentiment analysis model in classifying Twitter sentiment.



5.	Conclusion:
In this project, we successfully conducted sentiment analysis on Twitter data using machine learning techniques. By preprocessing the text data and building a classification model, we were able to accurately classify the sentiment of tweets as positive or negative. This study highlights the importance of sentiment analysis in understanding public opinion and sentiment trends on social media platforms like Twitter. Further improvements could be made by exploring advanced machine learning algorithms and incorporating more sophisticated text preprocessing techniques.
